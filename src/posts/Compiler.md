---
view: post
layout: post                          # Only in unique we use the "layout: post"
lang: en                              # Lang is required
author: 陈国强
title: Compiler Reform
description:
excerpt:
cover: false                         # Leave false if the post does not have cover image, if there is set to true
coverAlt:
demo:
categories:
  - Software_course
tags: 
  - vuejs
created_at: 2019-04-14 15:00
updated_at: 2019-04-14 15:00
meta:                                 # If you have cover image
  - property: og:image
    content: /images/posts/my-first-post.png
  - name: twitter:image
    content: /images/posts/my-first-post.png
---

## 引论  
+ 编译器：阅读某一种源语言并把该程序翻译为目标语言的程序  
解释器：不翻译语言，直接利用用户提供的输入执行源程序中指定的操作

+ 编译器结构：  
![编译器结构](../img/compiler_components.png)  

---  
**以下为编译前端**

1. 词法分析：  
<span style="color:red">输入</span>：以**词为单位**，词法分析器分析句子中的每个单词，包括分号，等号等  
<span style="color:red">输出</span>：词法单元`<种别码，属性值>`  
例如 position = initial + rate +60  
position被映射成<id, 1>，其中id代表identifier，1代表符号表中id所对应的条目，也可以用position代替  
= 被映射成<=>，不需要第二个分量，因为=是**一词一码**的  
initial被映射成<id, 2>，2代表initial对应符号表的条目  
\+、\*均会被映射为<\+>、<\*>  
空格会被词法分析器忽略  
![赋值语句的翻译](../img/translate_sentence.png)  

2. 语法分析：  
<span style="color:red">输入</span>：词法分析之后的词法单元流  
<span style="color:red">输出</span>：词法单元流的树形中间表示，即**语法树**  
该树显示了语句中各个运算的执行顺序  

3. 语义分析：  
<span style="color:red">输入</span>：语法分析之后的语法树  
<span style="color:red">输出</span>：检查过语义之后的语法树，具体涉及到类型检查与自动类型转换等  
类型检查：检查每个运算符是否具有匹配的运算分量，例如数组就不能有`array[1.5]`  

4. 中间代码生成：  
<span style="color:red">输入</span>：语义检查完整之后的语法树  
<span style="color:red">输出</span>：三地址码或者其他的中间指令，例如 z = x + y  
三地址指令：每一个指令的右边只能由最多一个运算符，可以没有；编译器应该生成一个临时的名字存放三地址指令计算得到的值  

**以上为编译前端**

---  
**以下为编译后端**

5. 代码优化：  
<span style="color:red">输入</span>：中间代码序列  
<span style="color:red">输出</span>：逻辑等价的优化代码序列  

6. 代码生成：  
<span style="color:red">输入</span>：中间代码序列  
<span style="color:red">输出</span>：目标语言，可以是机器代码，也可以是其他语言，到此，编译完毕  
生成机器代码的时候，需要为之分配内存与寄存器  

7. 符号表管理：  
记录源程序所用变量的名字与该名字的属性等  
记录各种保留字等其他信息  

**以上为编译后端**  
+ 其他：  
编译器的实现需要将多个步骤组合成一趟，每趟读入一个输入文件并产出一个输出文件  
编译器同时也可以将一个机器的二进制代码翻译为另一个机器的二进制代码，例如微软运行在高通处理器上的Windows系统就使用了二进制翻译器  
Java的编译前端都是生成相同的字节码，编译后端使用不同的解释器在不同的目标机器上执行  
类型检查：捕捉程序中的类型不匹配，比如返回值不匹配、传参不匹配，还能检查出更多的例如指针错误  
边界检查：处理数组越界、缓冲溢出等情况  
内存管理：例如Java的GC，而C与C++经常会有内存泄漏  
---  

+ 静态与动态语言的区别  
如果一个语言使用的策略支持编译器静态决定某个问题，那么就称这个语言使用了静态策略，或者这个问题可以在`编译时`确定  
如果一个语言只允许运行程序的时候做出决定，那么就称这个语言使用了动态策略，或者说这个问题需要在`运行时`确定 
 
Java的static关键字：  
例如声明 `public static int x; //static的意思是编译器可以静态确定这个变量的位置`  
这个x就是一个类变量，不管这个类有多少对象，都只有一个x的拷贝；并且，编译器可以静态确定这个变量在内存中的存放位置。  
反之，如果没有static关键字，编译器就只有动态确定这个变量的位置。 
Java把对象的引用当作值传递，这样两个形参指向同一个位置，这样两个变量互称为对方的别名 

C语言的静态策略：  
定义在函数内的变量，作用域被限制在它出现的那个函数内  
在顶层声明的变量x（顶层就是定义在所有函数之外的意思），那么它的作用域就是在声明之后的所有程序。  
如果之后的某个函数中也声明了x，那么该函数的语句就不在顶层x的作用范围内，并且C语言不能在函数内定义另一个函数  


+ 上下文无关文法：所有的产生式左边只有一个非终结符  
上下文有关文法：产生式左边可能有终结符  
 解释：  
``` 
在应用一个产生式进行推导时，前后已经推导出的部分结果就是上下文。  
 上下文无关的意思的，只要文法的定义里有某个产生式，不管一个非终结符前后的串是什么，就可以应用相应的产生式进行推导。  
 （从形式上来看，就是产生式的左边都是单独一个非终结符，即形如 S-> ...，而不是非终结符左右还有别的东西，例如 aSb -> ...）
举例：  
**上下文无关文法的产生式：**：  
    Sent -> S V O  
    S -> 人 | 天  
    V -> 吃 | 下  
    O -> 雨 | 雪 | 饭 | 肉  
其中英文字母都是非终结符（SVO 分别表示主谓宾），汉字都是终结符.  
这个文法可以生成如下句子：｛人吃饭，天下雨，人吃肉，天下雪，人下雪，天下饭，天吃肉，……｝
可以看到，其中有一些搭配在语义上是不恰当的，例如“天吃肉”。  
其（最左）推导过程为：Sent -> SVO -> 天VO -> 天吃O -> 天吃肉但是上下文无关文法里，因为有“V -> 吃 | 下”
这样一条产生式，V 就永远都可以推出“吃”这个词，它并不在乎应用“V -> 吃 | 下”这个产生式进行推导时 V 所在的上下文
（在这个例子里，就是”天VO“中 V 左右两边的字符串”天“和”O“）。
事实上，在 V 推出“吃”这一步，它的左边是“天”这个词，而”天“和”吃“不搭配，导致最后的句子读起来很奇怪。

**上下文有关文法的产生式：**：  
     Sent -> S V 
     OS -> 人 | 天
     人V -> 人吃
     天V -> 天下
     下O -> 下雨 | 下雪
     吃O -> 吃饭 | 吃肉
 可以看到，这里对 V 的推导过程施加了约束：虽然 V 还是能推出”吃“和”下“两个词，但是仅仅当 V 左边是”人“时，才允许它推导出”吃“；
 而当 V 左边是”天“时，允许它推导出”下“。这样通过上下文的约束，就保证了主谓搭配的一致性。
 类似地，包含 O 的产生式也约束了动宾搭配的一致性。这样一来，这个语言包含的句子就只有｛人吃饭，天下雨，人吃肉，天下雪｝这四条，都是语义上合理的。
 以”人吃饭“为例，推导过程为：Sent -> SVO -> 人VO -> 人吃O -> 人吃饭其中第三步推导是这样的：非终结符 V 的上文是“人”。
 因此可以应用“人V -> 人吃”这条产生式，得到“人VO -> 人吃O”。第四步也类似。
```  

## 语法制导翻译器  


## 参考文章  
[知乎：应该如何理解「上下文无关文法」？](https://www.zhihu.com/question/21833944)